     1→/**
     2→ * MCP Tools Registry
     3→ * All integration tools for the MCP server
     4→ */
     5→
     6→import * as gmail from './integrations/gmail.js';
     7→import * as calendar from './integrations/calendar.js';
     8→import * as notion from './integrations/notion.js';
     9→import * as linkedin from './integrations/linkedin.js';
    10→import * as perplexity from './integrations/perplexity.js';
    11→import * as telegram from './integrations/telegram.js';
    12→import * as slack from './integrations/slack.js';
    13→import * as sheets from './integrations/sheets.js';
    14→import * as n8n from './integrations/n8n.js';
    15→import * as docs from './integrations/docs.js';
    16→import * as notebooklm from './integrations/notebooklm.js';
    17→
    18→export interface Tool {
    19→  name: string;
    20→  description: string;
    21→  inputSchema: Record<string, unknown>;
    22→  handler: (params: Record<string, unknown>) => Promise<string>;
    23→}
    24→
    25→// Gmail Tools
    26→const gmailTools: Tool[] = [
    27→  {
    28→    name: 'gmail_list',
    29→    description: 'List recent emails or search inbox',
    30→    inputSchema: {
    31→      type: 'object',
    32→      properties: {
    33→        query: { type: 'string', description: 'Search query' },
    34→        maxResults: { type: 'number', default: 10 }
    35→      }
    36→    },
    37→    handler: async (params) => {
    38→      const emails = await gmail.listEmails(String(params.query || ''), Number(params.maxResults || 10));
    39→      return emails.map(e => `${e.date} | ${e.from}\n  ${e.subject}\n  ${e.snippet}`).join('\n\n') || 'No emails found';
    40→    }
    41→  },
    42→  {
    43→    name: 'gmail_read',
    44→    description: 'Read full email by ID',
    45→    inputSchema: {
    46→      type: 'object',
    47→      properties: { messageId: { type: 'string' } },
    48→      required: ['messageId']
    49→    },
    50→    handler: async (params) => {
    51→      const email = await gmail.getEmail(String(params.messageId));
    52→      if (!email) return 'Email not found';
    53→      return `From: ${email.from}\nTo: ${email.to}\nDate: ${email.date}\nSubject: ${email.subject}\n\n${email.body || email.snippet}`;
    54→    }
    55→  },
    56→  {
    57→    name: 'gmail_send',
    58→    description: 'Send an email',
    59→    inputSchema: {
    60→      type: 'object',
    61→      properties: {
    62→        to: { type: 'string' },
    63→        subject: { type: 'string' },
    64→        body: { type: 'string' }
    65→      },
    66→      required: ['to', 'subject', 'body']
    67→    },
    68→    handler: async (params) => {
    69→      const result = await gmail.sendEmail(String(params.to), String(params.subject), String(params.body));
    70→      return result.success ? `Sent: ${result.messageId}` : `Failed: ${result.error}`;
    71→    }
    72→  }
    73→];
    74→
    75→// Calendar Tools
    76→const calendarTools: Tool[] = [
    77→  {
    78→    name: 'calendar_today',
    79→    description: 'Get today\'s events',
    80→    inputSchema: { type: 'object', properties: {} },
    81→    handler: async () => {
    82→      const events = await calendar.getTodayEvents();
    83→      return events.length ? events.map(e => `${e.start} - ${e.end}: ${e.summary}`).join('\n') : 'No events today';
    84→    }
    85→  },
    86→  {
    87→    name: 'calendar_week',
    88→    description: 'Get this week\'s events',
    89→    inputSchema: { type: 'object', properties: {} },
    90→    handler: async () => {
    91→      const events = await calendar.getWeekEvents();
    92→      return events.length ? events.map(e => `${e.start} - ${e.end}: ${e.summary}`).join('\n') : 'No events this week';
    93→    }
    94→  },
    95→  {
    96→    name: 'calendar_create',
    97→    description: 'Create calendar event',
    98→    inputSchema: {
    99→      type: 'object',
   100→      properties: {
   101→        summary: { type: 'string' },
   102→        start: { type: 'string', description: 'ISO 8601' },
   103→        end: { type: 'string', description: 'ISO 8601' },
   104→        description: { type: 'string' },
   105→        location: { type: 'string' }
   106→      },
   107→      required: ['summary', 'start', 'end']
   108→    },
   109→    handler: async (params) => {
   110→      const result = await calendar.createEvent('primary', {
   111→        summary: String(params.summary),
   112→        start: String(params.start),
   113→        end: String(params.end),
   114→        description: params.description ? String(params.description) : undefined,
   115→        location: params.location ? String(params.location) : undefined
   116→      });
   117→      return result.success ? `Created: ${result.htmlLink}` : `Failed: ${result.error}`;
   118→    }
   119→  }
   120→];
   121→
   122→// Notion Tools
   123→const notionTools: Tool[] = [
   124→  {
   125→    name: 'notion_search',
   126→    description: 'Search Notion pages and databases',
   127→    inputSchema: {
   128→      type: 'object',
   129→      properties: {
   130→        query: { type: 'string' },
   131→        filter: { type: 'string', description: 'page or database' }
   132→      },
   133→      required: ['query']
   134→    },
   135→    handler: async (params) => {
   136→      const results = await notion.search(String(params.query), params.filter as 'page' | 'database' | undefined);
   137→      return results.map(r => `${r.title} - ${r.url}`).join('\n') || 'No results';
   138→    }
   139→  },
   140→  {
   141→    name: 'notion_databases',
   142→    description: 'List all Notion databases',
   143→    inputSchema: { type: 'object', properties: {} },
   144→    handler: async () => {
   145→      const dbs = await notion.listDatabases();
   146→      return dbs.map(d => `${d.title} (${d.id})`).join('\n') || 'No databases';
   147→    }
   148→  },
   149→  {
   150→    name: 'notion_query',
   151→    description: 'Query a Notion database',
   152→    inputSchema: {
   153→      type: 'object',
   154→      properties: { databaseId: { type: 'string' } },
   155→      required: ['databaseId']
   156→    },
   157→    handler: async (params) => {
   158→      const pages = await notion.queryDatabase(String(params.databaseId));
   159→      return pages.map(p => `${p.title} - ${p.url}`).join('\n') || 'No results';
   160→    }
   161→  },
   162→  {
   163→    name: 'notion_create_page',
   164→    description: 'Create a page in Notion database',
   165→    inputSchema: {
   166→      type: 'object',
   167→      properties: {
   168→        databaseId: { type: 'string' },
   169→        title: { type: 'string' },
   170→        properties: { type: 'string', description: 'JSON properties' }
   171→      },
   172→      required: ['databaseId', 'title']
   173→    },
   174→    handler: async (params) => {
   175→      const props = params.properties ? JSON.parse(String(params.properties)) : {};
   176→      props.Name = notion.propertyHelpers.title(String(params.title));
   177→      const page = await notion.createPage(String(params.databaseId), props);
   178→      return `Created: ${page.url}`;
   179→    }
   180→  }
   181→];
   182→
   183→// LinkedIn Tools
   184→const linkedinTools: Tool[] = [
   185→  {
   186→    name: 'linkedin_profile',
   187→    description: 'Get LinkedIn profile by URL',
   188→    inputSchema: {
   189→      type: 'object',
   190→      properties: { url: { type: 'string' } },
   191→      required: ['url']
   192→    },
   193→    handler: async (params) => {
   194→      const profile = await linkedin.getProfile(String(params.url));
   195→      if (!profile) return 'Profile not found';
   196→      return `${profile.firstName} ${profile.lastName}\n${profile.headline}\n${profile.location}\n${profile.currentCompany || ''} - ${profile.currentTitle || ''}`;
   197→    }
   198→  },
   199→  {
   200→    name: 'linkedin_search',
   201→    description: 'Search LinkedIn people',
   202→    inputSchema: {
   203→      type: 'object',
   204→      properties: {
   205→        keywords: { type: 'string' },
   206→        company: { type: 'string' },
   207→        title: { type: 'string' }
   208→      },
   209→      required: ['keywords']
   210→    },
   211→    handler: async (params) => {
   212→      const results = await linkedin.searchPeople(String(params.keywords), {
   213→        currentCompany: params.company ? String(params.company) : undefined,
   214→        title: params.title ? String(params.title) : undefined
   215→      });
   216→      return results.profiles.map(p => `${p.firstName} ${p.lastName} - ${p.headline}\n${p.profileUrl}`).join('\n\n') || 'No results';
   217→    }
   218→  }
   219→];
   220→
   221→// Perplexity Tools
   222→const perplexityTools: Tool[] = [
   223→  {
   224→    name: 'perplexity_search',
   225→    description: 'AI-powered web search via Perplexity',
   226→    inputSchema: {
   227→      type: 'object',
   228→      properties: {
   229→        query: { type: 'string' },
   230→        depth: { type: 'string', description: 'quick, standard, or deep' }
   231→      },
   232→      required: ['query']
   233→    },
   234→    handler: async (params) => {
   235→      const result = await perplexity.research(String(params.query), {
   236→        depth: (params.depth as 'quick' | 'standard' | 'deep') || 'standard'
   237→      });
   238→      return `${result.answer}\n\nSources:\n${result.citations.join('\n')}`;
   239→    }
   240→  },
   241→  {
   242→    name: 'perplexity_factcheck',
   243→    description: 'Fact-check a claim',
   244→    inputSchema: {
   245→      type: 'object',
   246→      properties: { claim: { type: 'string' } },
   247→      required: ['claim']
   248→    },
   249→    handler: async (params) => {
   250→      const result = await perplexity.factCheck(String(params.claim));
   251→      return `Verdict: ${result.verdict}\n\n${result.explanation}\n\nSources:\n${result.citations.join('\n')}`;
   252→    }
   253→  }
   254→];
   255→
   256→// Telegram Tools
   257→const telegramTools: Tool[] = [
   258→  {
   259→    name: 'telegram_send',
   260→    description: 'Send Telegram message',
   261→    inputSchema: {
   262→      type: 'object',
   263→      properties: {
   264→        chatId: { type: 'string' },
   265→        text: { type: 'string' }
   266→      },
   267→      required: ['text']
   268→    },
   269→    handler: async (params) => {
   270→      if (params.chatId) {
   271→        const msg = await telegram.sendMessage(String(params.chatId), String(params.text));
   272→        return `Sent message ${msg.message_id}`;
   273→      } else {
   274→        const msg = await telegram.sendNotification(String(params.text));
   275→        return `Sent notification ${msg.message_id}`;
   276→      }
   277→    }
   278→  },
   279→  {
   280→    name: 'telegram_notify',
   281→    description: 'Send notification to default chat',
   282→    inputSchema: {
   283→      type: 'object',
   284→      properties: { text: { type: 'string' } },
   285→      required: ['text']
   286→    },
   287→    handler: async (params) => {
   288→      const msg = await telegram.sendNotification(String(params.text));
   289→      return `Sent: ${msg.message_id}`;
   290→    }
   291→  }
   292→];
   293→
   294→// Slack Tools
   295→const slackTools: Tool[] = [
   296→  {
   297→    name: 'slack_send',
   298→    description: 'Send Slack message',
   299→    inputSchema: {
   300→      type: 'object',
   301→      properties: {
   302→        channel: { type: 'string' },
   303→        text: { type: 'string' }
   304→      },
   305→      required: ['text']
   306→    },
   307→    handler: async (params) => {
   308→      if (params.channel) {
   309→        const msg = await slack.sendMessage(String(params.channel), String(params.text));
   310→        return `Sent: ${msg.ts}`;
   311→      } else {
   312→        const msg = await slack.sendNotification(String(params.text));
   313→        return `Sent: ${msg.ts}`;
   314→      }
   315→    }
   316→  },
   317→  {
   318→    name: 'slack_channels',
   319→    description: 'List Slack channels',
   320→    inputSchema: { type: 'object', properties: {} },
   321→    handler: async () => {
   322→      const channels = await slack.listChannels();
   323→      return channels.map(c => `#${c.name} (${c.id})`).join('\n') || 'No channels';
   324→    }
   325→  },
   326→  {
   327→    name: 'slack_history',
   328→    description: 'Get channel history',
   329→    inputSchema: {
   330→      type: 'object',
   331→      properties: {
   332→        channel: { type: 'string' },
   333→        limit: { type: 'number', default: 10 }
   334→      },
   335→      required: ['channel']
   336→    },
   337→    handler: async (params) => {
   338→      const messages = await slack.getChannelHistory(String(params.channel), {
   339→        limit: Number(params.limit || 10)
   340→      });
   341→      return messages.map(m => `${m.user}: ${m.text}`).join('\n') || 'No messages';
   342→    }
   343→  }
   344→];
   345→
   346→// Google Sheets Tools
   347→const sheetsTools: Tool[] = [
   348→  {
   349→    name: 'sheets_read',
   350→    description: 'Read data from Google Sheets',
   351→    inputSchema: {
   352→      type: 'object',
   353→      properties: {
   354→        spreadsheetId: { type: 'string' },
   355→        range: { type: 'string', description: 'A1 notation, e.g. Sheet1!A1:D10' }
   356→      },
   357→      required: ['spreadsheetId', 'range']
   358→    },
   359→    handler: async (params) => {
   360→      const data = await sheets.getRange(String(params.spreadsheetId), String(params.range));
   361→      return data.values.map(row => row.join('\t')).join('\n') || 'No data';
   362→    }
   363→  },
   364→  {
   365→    name: 'sheets_write',
   366→    description: 'Write data to Google Sheets',
   367→    inputSchema: {
   368→      type: 'object',
   369→      properties: {
   370→        spreadsheetId: { type: 'string' },
   371→        range: { type: 'string' },
   372→        values: { type: 'string', description: 'JSON 2D array' }
   373→      },
   374→      required: ['spreadsheetId', 'range', 'values']
   375→    },
   376→    handler: async (params) => {
   377→      const values = JSON.parse(String(params.values));
   378→      const result = await sheets.updateRange(String(params.spreadsheetId), String(params.range), values);
   379→      return `Updated ${result.updatedCells} cells`;
   380→    }
   381→  },
   382→  {
   383→    name: 'sheets_append',
   384→    description: 'Append rows to Google Sheets',
   385→    inputSchema: {
   386→      type: 'object',
   387→      properties: {
   388→        spreadsheetId: { type: 'string' },
   389→        range: { type: 'string' },
   390→        values: { type: 'string', description: 'JSON 2D array' }
   391→      },
   392→      required: ['spreadsheetId', 'range', 'values']
   393→    },
   394→    handler: async (params) => {
   395→      const values = JSON.parse(String(params.values));
   396→      const result = await sheets.appendRows(String(params.spreadsheetId), String(params.range), values);
   397→      return `Appended ${result.updatedRows} rows`;
   398→    }
   399→  }
   400→];
   401→
   402→// n8n Tools
   403→const n8nTools: Tool[] = [
   404→  {
   405→    name: 'n8n_workflows',
   406→    description: 'List n8n workflows',
   407→    inputSchema: { type: 'object', properties: {} },
   408→    handler: async () => {
   409→      const workflows = await n8n.listWorkflows();
   410→      return workflows.map(w => `${w.name} (${w.id}) - ${w.active ? 'active' : 'inactive'}`).join('\n') || 'No workflows';
   411→    }
   412→  },
   413→  {
   414→    name: 'n8n_trigger',
   415→    description: 'Trigger n8n webhook',
   416→    inputSchema: {
   417→      type: 'object',
   418→      properties: {
   419→        webhook: { type: 'string', description: 'Webhook path or ID' },
   420→        data: { type: 'string', description: 'JSON data' }
   421→      },
   422→      required: ['webhook']
   423→    },
   424→    handler: async (params) => {
   425→      const data = params.data ? JSON.parse(String(params.data)) : undefined;
   426→      const result = await n8n.triggerWebhook(String(params.webhook), data);
   427→      return result.success ? `Triggered: ${JSON.stringify(result.data)}` : `Failed: ${result.error}`;
   428→    }
   429→  },
   430→  {
   431→    name: 'n8n_executions',
   432→    description: 'List recent n8n executions',
   433→    inputSchema: {
   434→      type: 'object',
   435→      properties: {
   436→        workflowId: { type: 'string' },
   437→        limit: { type: 'number', default: 10 }
   438→      }
   439→    },
   440→    handler: async (params) => {
   441→      const executions = await n8n.listExecutions({
   442→        workflowId: params.workflowId ? String(params.workflowId) : undefined,
   443→        limit: Number(params.limit || 10)
   444→      });
   445→      return executions.map(e => `${e.id} - ${e.status} (${e.startedAt})`).join('\n') || 'No executions';
   446→    }
   447→  }
   448→];
   449→
   450→// Google Docs Tools
   451→const docsTools: Tool[] = [
   452→  {
   453→    name: 'docs_get',
   454→    description: 'Get Google Doc content by ID',
   455→    inputSchema: {
   456→      type: 'object',
   457→      properties: { documentId: { type: 'string' } },
   458→      required: ['documentId']
   459→    },
   460→    handler: async (params) => {
   461→      const doc = await docs.getDocument(String(params.documentId));
   462→      return `Title: ${doc.title}\n\n${doc.content}`;
   463→    }
   464→  },
   465→  {
   466→    name: 'docs_create',
   467→    description: 'Create a new Google Doc',
   468→    inputSchema: {
   469→      type: 'object',
   470→      properties: { title: { type: 'string' } },
   471→      required: ['title']
   472→    },
   473→    handler: async (params) => {
   474→      const doc = await docs.createDocument(String(params.title));
   475→      return `Created: ${doc.title}\nURL: ${doc.url}`;
   476→    }
   477→  },
   478→  {
   479→    name: 'docs_append',
   480→    description: 'Append text to Google Doc',
   481→    inputSchema: {
   482→      type: 'object',
   483→      properties: {
   484→        documentId: { type: 'string' },
   485→        text: { type: 'string' }
   486→      },
   487→      required: ['documentId', 'text']
   488→    },
   489→    handler: async (params) => {
   490→      await docs.appendText(String(params.documentId), String(params.text));
   491→      return 'Text appended successfully';
   492→    }
   493→  },
   494→  {
   495→    name: 'docs_search',
   496→    description: 'Search Google Docs',
   497→    inputSchema: {
   498→      type: 'object',
   499→      properties: {
   500→        query: { type: 'string' },
   501→        maxResults: { type: 'number', default: 10 }
   502→      },
   503→      required: ['query']
   504→    },
   505→    handler: async (params) => {
   506→      const results = await docs.searchDocuments(String(params.query), Number(params.maxResults || 10));
   507→      return results.map(r => `${r.name}\n${r.url}`).join('\n\n') || 'No documents found';
   508→    }
   509→  },
   510→  {
   511→    name: 'docs_replace',
   512→    description: 'Replace text in Google Doc',
   513→    inputSchema: {
   514→      type: 'object',
   515→      properties: {
   516→        documentId: { type: 'string' },
   517→        searchText: { type: 'string' },
   518→        replaceText: { type: 'string' }
   519→      },
   520→      required: ['documentId', 'searchText', 'replaceText']
   521→    },
   522→    handler: async (params) => {
   523→      const count = await docs.replaceText(
   524→        String(params.documentId),
   525→        String(params.searchText),
   526→        String(params.replaceText)
   527→      );
   528→      return `Replaced ${count} occurrences`;
   529→    }
   530→  }
   531→];
   532→
   533→// NotebookLM Tools
   534→const notebookTools: Tool[] = [
   535→  {
   536→    name: 'notebook_create',
   537→    description: 'Create a research notebook',
   538→    inputSchema: {
   539→      type: 'object',
   540→      properties: {
   541→        name: { type: 'string' },
   542→        description: { type: 'string' }
   543→      },
   544→      required: ['name']
   545→    },
   546→    handler: async (params) => {
   547→      const nb = notebooklm.createNotebook(String(params.name), params.description ? String(params.description) : undefined);
   548→      return `Created notebook: ${nb.name} (${nb.id})`;
   549→    }
   550→  },
   551→  {
   552→    name: 'notebook_list',
   553→    description: 'List all notebooks',
   554→    inputSchema: { type: 'object', properties: {} },
   555→    handler: async () => {
   556→      const notebooks = notebooklm.listNotebooks();
   557→      return notebooks.map(n => `${n.name} (${n.id}) - ${n.sources.length} sources`).join('\n') || 'No notebooks';
   558→    }
   559→  },
   560→  {
   561→    name: 'notebook_add_text',
   562→    description: 'Add text source to notebook',
   563→    inputSchema: {
   564→      type: 'object',
   565→      properties: {
   566→        notebookId: { type: 'string' },
   567→        title: { type: 'string' },
   568→        content: { type: 'string' }
   569→      },
   570→      required: ['notebookId', 'title', 'content']
   571→    },
   572→    handler: async (params) => {
   573→      const source = notebooklm.addTextSource(
   574→        String(params.notebookId),
   575→        String(params.title),
   576→        String(params.content)
   577→      );
   578→      return source ? `Added source: ${source.title}` : 'Notebook not found';
   579→    }
   580→  },
   581→  {
   582→    name: 'notebook_add_url',
   583→    description: 'Add URL source to notebook',
   584→    inputSchema: {
   585→      type: 'object',
   586→      properties: {
   587→        notebookId: { type: 'string' },
   588→        title: { type: 'string' },
   589→        url: { type: 'string' }
   590→      },
   591→      required: ['notebookId', 'title', 'url']
   592→    },
   593→    handler: async (params) => {
   594→      const source = notebooklm.addUrlSource(
   595→        String(params.notebookId),
   596→        String(params.title),
   597→        String(params.url)
   598→      );
   599→      return source ? `Added URL source: ${source.title}` : 'Notebook not found';
   600→    }
   601→  },
   602→  {
   603→    name: 'notebook_analyze',
   604→    description: 'Generate analysis prompt from notebook sources',
   605→    inputSchema: {
   606→      type: 'object',
   607→      properties: { notebookId: { type: 'string' } },
   608→      required: ['notebookId']
   609→    },
   610→    handler: async (params) => {
   611→      const prompt = notebooklm.generateAnalysisPrompt(String(params.notebookId));
   612→      return prompt || 'Notebook not found';
   613→    }
   614→  },
   615→  {
   616→    name: 'notebook_export',
   617→    description: 'Export notebook sources for NotebookLM import',
   618→    inputSchema: {
   619→      type: 'object',
   620→      properties: { notebookId: { type: 'string' } },
   621→      required: ['notebookId']
   622→    },
   623→    handler: async (params) => {
   624→      const data = notebooklm.exportForNotebookLM(String(params.notebookId));
   625→      return JSON.stringify(data, null, 2);
   626→    }
   627→  }
   628→];
   629→
   630→// Export all tools
   631→export const INTEGRATION_TOOLS: Tool[] = [
   632→  ...gmailTools,
   633→  ...calendarTools,
   634→  ...notionTools,
   635→  ...linkedinTools,
   636→  ...perplexityTools,
   637→  ...telegramTools,
   638→  ...slackTools,
   639→  ...sheetsTools,
   640→  ...n8nTools,
   641→  ...docsTools,
   642→  ...notebookTools
   643→];
   644→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
