     1→/**
     2→ * Slack Integration
     3→ * Send messages, read channels, manage workspace
     4→ */
     5→
     6→import * as fs from 'fs';
     7→import * as https from 'https';
     8→
     9→const CREDENTIALS_PATH = '/root/.claude/secrets/slack-credentials.json';
    10→
    11→interface SlackCredentials {
    12→  bot_token: string;          // xoxb-...
    13→  user_token?: string;        // xoxp-... (for user actions)
    14→  default_channel?: string;
    15→}
    16→
    17→interface SlackMessage {
    18→  ts: string;
    19→  text: string;
    20→  user?: string;
    21→  channel: string;
    22→  thread_ts?: string;
    23→}
    24→
    25→interface SlackChannel {
    26→  id: string;
    27→  name: string;
    28→  is_private: boolean;
    29→  is_member: boolean;
    30→  topic?: { value: string };
    31→  purpose?: { value: string };
    32→}
    33→
    34→interface SlackUser {
    35→  id: string;
    36→  name: string;
    37→  real_name: string;
    38→  email?: string;
    39→  is_bot: boolean;
    40→  profile: {
    41→    display_name: string;
    42→    image_72?: string;
    43→  };
    44→}
    45→
    46→function loadCredentials(): SlackCredentials | null {
    47→  if (!fs.existsSync(CREDENTIALS_PATH)) {
    48→    return null;
    49→  }
    50→  return JSON.parse(fs.readFileSync(CREDENTIALS_PATH, 'utf-8'));
    51→}
    52→
    53→async function slackRequest(
    54→  method: string,
    55→  params: Record<string, unknown> = {},
    56→  useUserToken = false
    57→): Promise<unknown> {
    58→  const credentials = loadCredentials();
    59→  if (!credentials) {
    60→    throw new Error('Slack not authenticated');
    61→  }
    62→
    63→  const token = useUserToken ? credentials.user_token : credentials.bot_token;
    64→  if (!token) {
    65→    throw new Error(useUserToken ? 'User token not configured' : 'Bot token not configured');
    66→  }
    67→
    68→  return new Promise((resolve, reject) => {
    69→    const body = JSON.stringify(params);
    70→
    71→    const options: https.RequestOptions = {
    72→      hostname: 'slack.com',
    73→      path: `/api/${method}`,
    74→      method: 'POST',
    75→      headers: {
    76→        'Authorization': `Bearer ${token}`,
    77→        'Content-Type': 'application/json; charset=utf-8'
    78→      }
    79→    };
    80→
    81→    const req = https.request(options, (res) => {
    82→      let data = '';
    83→      res.on('data', chunk => data += chunk);
    84→      res.on('end', () => {
    85→        try {
    86→          const json = JSON.parse(data);
    87→          if (!json.ok) {
    88→            reject(new Error(json.error || 'Slack API error'));
    89→          } else {
    90→            resolve(json);
    91→          }
    92→        } catch {
    93→          reject(new Error('Invalid response from Slack'));
    94→        }
    95→      });
    96→    });
    97→
    98→    req.on('error', reject);
    99→    req.write(body);
   100→    req.end();
   101→  });
   102→}
   103→
   104→// Messages
   105→
   106→export async function sendMessage(
   107→  channel: string,
   108→  text: string,
   109→  options: {
   110→    threadTs?: string;
   111→    blocks?: unknown[];
   112→    unfurlLinks?: boolean;
   113→  } = {}
   114→): Promise<SlackMessage> {
   115→  const params: Record<string, unknown> = {
   116→    channel,
   117→    text
   118→  };
   119→
   120→  if (options.threadTs) params.thread_ts = options.threadTs;
   121→  if (options.blocks) params.blocks = options.blocks;
   122→  if (options.unfurlLinks !== undefined) params.unfurl_links = options.unfurlLinks;
   123→
   124→  const response = await slackRequest('chat.postMessage', params) as {
   125→    ts: string;
   126→    channel: string;
   127→    message: { text: string };
   128→  };
   129→
   130→  return {
   131→    ts: response.ts,
   132→    text: response.message.text,
   133→    channel: response.channel
   134→  };
   135→}
   136→
   137→export async function sendNotification(text: string): Promise<SlackMessage> {
   138→  const credentials = loadCredentials();
   139→  if (!credentials?.default_channel) {
   140→    throw new Error('No default_channel configured');
   141→  }
   142→
   143→  return sendMessage(credentials.default_channel, text);
   144→}
   145→
   146→export async function updateMessage(
   147→  channel: string,
   148→  ts: string,
   149→  text: string
   150→): Promise<SlackMessage> {
   151→  const response = await slackRequest('chat.update', {
   152→    channel,
   153→    ts,
   154→    text
   155→  }) as { ts: string; channel: string; text: string };
   156→
   157→  return {
   158→    ts: response.ts,
   159→    text: response.text,
   160→    channel: response.channel
   161→  };
   162→}
   163→
   164→export async function deleteMessage(channel: string, ts: string): Promise<boolean> {
   165→  await slackRequest('chat.delete', { channel, ts });
   166→  return true;
   167→}
   168→
   169→export async function addReaction(
   170→  channel: string,
   171→  ts: string,
   172→  emoji: string
   173→): Promise<boolean> {
   174→  await slackRequest('reactions.add', {
   175→    channel,
   176→    timestamp: ts,
   177→    name: emoji.replace(/:/g, '')
   178→  });
   179→  return true;
   180→}
   181→
   182→// Channels
   183→
   184→export async function listChannels(
   185→  options: { excludeArchived?: boolean; limit?: number } = {}
   186→): Promise<SlackChannel[]> {
   187→  const response = await slackRequest('conversations.list', {
   188→    exclude_archived: options.excludeArchived ?? true,
   189→    limit: options.limit || 100,
   190→    types: 'public_channel,private_channel'
   191→  }) as { channels: SlackChannel[] };
   192→
   193→  return response.channels.map(ch => ({
   194→    id: ch.id,
   195→    name: ch.name,
   196→    is_private: ch.is_private,
   197→    is_member: ch.is_member,
   198→    topic: ch.topic,
   199→    purpose: ch.purpose
   200→  }));
   201→}
   202→
   203→export async function getChannel(channelId: string): Promise<SlackChannel> {
   204→  const response = await slackRequest('conversations.info', {
   205→    channel: channelId
   206→  }) as { channel: SlackChannel };
   207→
   208→  return response.channel;
   209→}
   210→
   211→export async function getChannelHistory(
   212→  channel: string,
   213→  options: { limit?: number; oldest?: string; latest?: string } = {}
   214→): Promise<SlackMessage[]> {
   215→  const params: Record<string, unknown> = {
   216→    channel,
   217→    limit: options.limit || 20
   218→  };
   219→
   220→  if (options.oldest) params.oldest = options.oldest;
   221→  if (options.latest) params.latest = options.latest;
   222→
   223→  const response = await slackRequest('conversations.history', params) as {
   224→    messages: Array<{
   225→      ts: string;
   226→      text: string;
   227→      user?: string;
   228→      thread_ts?: string;
   229→    }>;
   230→  };
   231→
   232→  return response.messages.map(msg => ({
   233→    ts: msg.ts,
   234→    text: msg.text,
   235→    user: msg.user,
   236→    channel,
   237→    thread_ts: msg.thread_ts
   238→  }));
   239→}
   240→
   241→export async function joinChannel(channelId: string): Promise<boolean> {
   242→  await slackRequest('conversations.join', { channel: channelId });
   243→  return true;
   244→}
   245→
   246→// Users
   247→
   248→export async function listUsers(): Promise<SlackUser[]> {
   249→  const response = await slackRequest('users.list') as {
   250→    members: SlackUser[];
   251→  };
   252→
   253→  return response.members.filter(u => !u.is_bot).map(u => ({
   254→    id: u.id,
   255→    name: u.name,
   256→    real_name: u.real_name,
   257→    email: u.profile?.display_name,
   258→    is_bot: u.is_bot,
   259→    profile: u.profile
   260→  }));
   261→}
   262→
   263→export async function getUser(userId: string): Promise<SlackUser> {
   264→  const response = await slackRequest('users.info', {
   265→    user: userId
   266→  }) as { user: SlackUser };
   267→
   268→  return response.user;
   269→}
   270→
   271→export async function getUserByEmail(email: string): Promise<SlackUser | null> {
   272→  try {
   273→    const response = await slackRequest('users.lookupByEmail', {
   274→      email
   275→    }) as { user: SlackUser };
   276→
   277→    return response.user;
   278→  } catch {
   279→    return null;
   280→  }
   281→}
   282→
   283→// Direct messages
   284→
   285→export async function openDM(userId: string): Promise<string> {
   286→  const response = await slackRequest('conversations.open', {
   287→    users: userId
   288→  }) as { channel: { id: string } };
   289→
   290→  return response.channel.id;
   291→}
   292→
   293→export async function sendDM(userId: string, text: string): Promise<SlackMessage> {
   294→  const channelId = await openDM(userId);
   295→  return sendMessage(channelId, text);
   296→}
   297→
   298→// Search (requires user token)
   299→
   300→export async function searchMessages(
   301→  query: string,
   302→  options: { count?: number } = {}
   303→): Promise<SlackMessage[]> {
   304→  const response = await slackRequest('search.messages', {
   305→    query,
   306→    count: options.count || 20
   307→  }, true) as {
   308→    messages: {
   309→      matches: Array<{
   310→        ts: string;
   311→        text: string;
   312→        user: string;
   313→        channel: { id: string };
   314→      }>;
   315→    };
   316→  };
   317→
   318→  return response.messages.matches.map(msg => ({
   319→    ts: msg.ts,
   320→    text: msg.text,
   321→    user: msg.user,
   322→    channel: msg.channel.id
   323→  }));
   324→}
   325→
   326→// Rich formatting helpers
   327→
   328→export const formatters = {
   329→  bold: (text: string) => `*${text}*`,
   330→  italic: (text: string) => `_${text}_`,
   331→  strike: (text: string) => `~${text}~`,
   332→  code: (text: string) => `\`${text}\``,
   333→  codeBlock: (text: string, lang = '') => `\`\`\`${lang}\n${text}\n\`\`\``,
   334→  link: (url: string, text?: string) => text ? `<${url}|${text}>` : `<${url}>`,
   335→  user: (userId: string) => `<@${userId}>`,
   336→  channel: (channelId: string) => `<#${channelId}>`,
   337→  emoji: (name: string) => `:${name}:`
   338→};
   339→
   340→export function isAuthenticated(): boolean {
   341→  return loadCredentials() !== null;
   342→}
   343→
   344→export function getAuthInstructions(): string {
   345→  return `
   346→Slack Integration Setup:
   347→
   348→1. Create a Slack App at https://api.slack.com/apps
   349→2. Add Bot Token Scopes:
   350→   - chat:write
   351→   - channels:read
   352→   - channels:history
   353→   - users:read
   354→   - reactions:write
   355→3. Install app to workspace
   356→4. Get Bot User OAuth Token (xoxb-...)
   357→5. Create /root/.claude/secrets/slack-credentials.json:
   358→   {
   359→     "bot_token": "xoxb-YOUR_TOKEN",
   360→     "default_channel": "C0123456789"
   361→   }
   362→
   363→Optional: Add user token for search functionality:
   364→   {
   365→     "bot_token": "xoxb-...",
   366→     "user_token": "xoxp-...",
   367→     "default_channel": "C0123456789"
   368→   }
   369→`;
   370→}
   371→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
